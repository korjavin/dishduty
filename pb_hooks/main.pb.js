// pb_hooks/main.pb.js

/**
 * Helper function to format a Date object to 'YYYY-MM-DD' string in UTC.
 * @param {Date} date
 * @returns {string}
 */
function formatDateToYMD(date) {
    return date.toISOString().split('T')[0];
}

/**
 * Helper function to get today's date as 'YYYY-MM-DD' string in UTC.
 * @returns {string}
 */
function getTodayYMD() {
    return formatDateToYMD(new Date());
}

/**
 * Helper function to add a number of days to a 'YYYY-MM-DD' string.
 * Returns a new 'YYYY-MM-DD' string.
 * @param {string} ymdString - Date in 'YYYY-MM-DD' format.
 * @param {number} days - Number of days to add.
 * @returns {string}
 */
function addDaysToYMD(ymdString, days) {
    const date = new Date(ymdString + "T00:00:00.000Z"); // Ensure UTC context by adding time and Z
    date.setUTCDate(date.getUTCDate() + days);
    return formatDateToYMD(date);
}

/**
 * Checks if the provided admin password matches the one set in ENV.
 * @param {string} providedPassword
 * @returns {boolean}
 */
function isAdmin(providedPassword) {
    const adminPass = process.env.ADMIN_PASS;
    if (!adminPass) {
        console.error("ADMIN_PASS environment variable is not set. Protected actions will fail.");
        return false;
    }
    return providedPassword === adminPass;
}

/**
 * Logs an action to the action_log collection.
 * @param {string} actionType
 * @param {object} details
 */
async function logAction(actionType, details) {
    try {
        const collection = $app.dao().findCollectionByNameOrId("action_log");
        const record = new Record(collection, {
            action_type: actionType,
            details: details || {},
            // timestamp is auto-generated by PocketBase
        });
        await $app.dao().saveRecord(record);
    } catch (e) {
        console.error(`Failed to log action '${actionType}':`, e);
    }
}

/**
 * API Endpoint: Add a worker to the assignment queue.
 * POST /api/dishduty/queue/add
 * Body: { worker_name: string, duration_days: number (1-7), admin_password: string }
 * or { worker_id: string, duration_days: number (1-7), admin_password: string }
 */
routerAdd("POST", "/api/dishduty/queue/add", async (c) => {
    const data = $apis.requestInfo(c).data;
    if (!isAdmin(data.admin_password)) {
        return c.json(403, { error: "Forbidden: Invalid admin password." });
    }

    if (!data.duration_days || data.duration_days < 1 || data.duration_days > 7) {
        return c.json(400, { error: "Bad Request: duration_days must be between 1 and 7." });
    }

    let worker;
    try {
        if (data.worker_id) {
            worker = await $app.dao().findRecordById("workers", data.worker_id);
        } else if (data.worker_name) {
            worker = await $app.dao().findFirstRecordByFilter("workers", "name = {:name}", { name: data.worker_name });
        } else {
            return c.json(400, { error: "Bad Request: worker_id or worker_name is required." });
        }
        if (!worker) {
            return c.json(404, { error: "Not Found: Worker not found." });
        }
    } catch (e) {
        console.error("Error finding worker:", e);
        return c.json(500, { error: "Internal Server Error: Could not find worker." });
    }

    try {
        let startDateYMD;
        let order = 1;

        // Find the last item in the queue to determine start_date and order
        const lastQueueItem = await $app.dao().findFirstRecordByFilter(
            "assignment_queue",
            "1=1 ORDER BY order DESC" // Get the one with the highest order
        );

        if (lastQueueItem) {
            const lastQueueItemEndDate = addDaysToYMD(lastQueueItem.get("start_date").split("T")[0], lastQueueItem.get("duration_days") -1);
            startDateYMD = addDaysToYMD(lastQueueItemEndDate, 1);
            order = lastQueueItem.get("order") + 1;
        } else {
            // If queue is empty, check current assignments
            const todayYMD = getTodayYMD();
            const latestAssignment = await $app.dao().findFirstRecordByFilter(
                "assignments",
                "1=1 ORDER BY date DESC"
            );

            if (latestAssignment) {
                const latestAssignmentDate = latestAssignment.get("date").split("T")[0];
                if (new Date(latestAssignmentDate) >= new Date(todayYMD)) {
                     startDateYMD = addDaysToYMD(latestAssignmentDate, 1);
                } else {
                    startDateYMD = todayYMD;
                }
            } else {
                startDateYMD = todayYMD; // No assignments, start today
            }
        }


        const queueCollection = $app.dao().findCollectionByNameOrId("assignment_queue");
        const newQueueRecord = new Record(queueCollection, {
            worker_id: worker.id,
            start_date: startDateYMD + " 00:00:00.000Z", // Store as full datetime string for PB
            duration_days: data.duration_days,
            order: order,
        });

        await $app.dao().saveRecord(newQueueRecord);
        await logAction("added_to_queue", {
            worker_id: worker.id,
            worker_name: worker.get("name"),
            duration_days: data.duration_days,
            start_date: startDateYMD,
            order: order,
        });

        return c.json(201, { message: "Worker added to queue.", data: newQueueRecord });
    } catch (e) {
        console.error("Error adding to queue:", e);
        return c.json(500, { error: "Internal Server Error: Could not add worker to queue." });
    }
});


/**
 * Processes the assignment queue and assigns a worker if needed.
 * This function is intended to be called daily (e.g., by a cron job or a trigger).
 */
async function processDailyAssignments() {
    const todayYMD = getTodayYMD();
    const todayFull = todayYMD + " 00:00:00.000Z";

    // 1. Check if anyone is already assigned for today
    const existingAssignmentToday = await $app.dao().findFirstRecordByFilter(
        "assignments",
        "date = {:today} AND status = 'assigned'",
        { today: todayFull }
    );

    if (existingAssignmentToday) {
        console.log(`Worker ${existingAssignmentToday.get("worker_id")} already assigned for ${todayYMD}. No action needed.`);
        return { message: "Assignment already exists for today.", assigned_worker_id: existingAssignmentToday.get("worker_id") };
    }

    // 2. Process the queue
    const dueQueueItem = await $app.dao().findFirstRecordByFilter(
        "assignment_queue",
        "start_date <= {:today} ORDER BY order ASC", // Process oldest due item first
        { today: todayFull }
    );

    if (dueQueueItem) {
        const workerId = dueQueueItem.get("worker_id");
        const duration = dueQueueItem.get("duration_days");
        let effectiveStartDate = dueQueueItem.get("start_date").split("T")[0];

        // If queue item's start_date is in the past, start assignments from today
        if (new Date(effectiveStartDate) < new Date(todayYMD)) {
            effectiveStartDate = todayYMD;
        }

        const assignmentsCollection = $app.dao().findCollectionByNameOrId("assignments");
        const worker = await $app.dao().findRecordById("workers", workerId);

        for (let i = 0; i < duration; i++) {
            const assignmentDate = addDaysToYMD(effectiveStartDate, i);
            const assignmentDateFull = assignmentDate + " 00:00:00.000Z";

            // Check if an assignment for this worker and date already exists (e.g. from a "not_done" scenario)
            const existingAssignment = await $app.dao().findFirstRecordByFilter(
                "assignments",
                "worker_id = {:workerId} AND date = {:date}",
                { workerId: workerId, date: assignmentDateFull }
            );

            if (existingAssignment) {
                if (existingAssignment.get("status") !== "assigned") {
                    existingAssignment.set("status", "assigned"); // Ensure it's marked assigned
                    await $app.dao().saveRecord(existingAssignment);
                }
                console.log(`Assignment for ${worker.get("name")} on ${assignmentDate} already exists, status updated if needed.`);
            } else {
                 const newAssignment = new Record(assignmentsCollection, {
                    worker_id: workerId,
                    date: assignmentDateFull,
                    status: "assigned",
                });
                await $app.dao().saveRecord(newAssignment);
            }
        }

        await $app.dao().deleteRecord(dueQueueItem); // Remove from queue

        // Update worker's last_assigned_date
        worker.set("last_assigned_date", addDaysToYMD(effectiveStartDate, duration - 1) + " 00:00:00.000Z");
        await $app.dao().saveRecord(worker);

        await logAction("queue_processed", {
            worker_id: workerId,
            worker_name: worker.get("name"),
            duration_days: duration,
            start_date: effectiveStartDate,
        });
        console.log(`Assigned ${worker.get("name")} for ${duration} days starting ${effectiveStartDate} from queue.`);
        return { message: "Worker assigned from queue.", assigned_worker_id: workerId, duration: duration };
    }

    // 3. Random assignment if no one assigned and queue is empty or not due
    console.log("No due queue item. Attempting random assignment.");
    const workers = await $app.dao().findRecordsByFilter(
        "workers",
        "1=1 ORDER BY last_assigned_date ASC NULLS FIRST, created ASC" // Prioritize those never assigned or oldest last_assigned_date
    );

    if (workers.length === 0) {
        console.error("No workers available for random assignment.");
        await logAction("random_assignment_failed", { reason: "No workers in the system." });
        return { error: "No workers available." };
    }

    const selectedWorker = workers[0]; // Simplest: pick the first one from the sorted list
    const assignmentsCollection = $app.dao().findCollectionByNameOrId("assignments");
    const newAssignment = new Record(assignmentsCollection, {
        worker_id: selectedWorker.id,
        date: todayFull,
        status: "assigned",
    });
    await $app.dao().saveRecord(newAssignment);

    selectedWorker.set("last_assigned_date", todayFull);
    await $app.dao().saveRecord(selectedWorker);

    await logAction("randomly_assigned", {
        worker_id: selectedWorker.id,
        worker_name: selectedWorker.get("name"),
        date: todayYMD,
    });
    console.log(`Randomly assigned ${selectedWorker.get("name")} for ${todayYMD}.`);
    return { message: "Worker randomly assigned.", assigned_worker_id: selectedWorker.id };
}

/**
 * API Endpoint: Trigger daily assignment logic.
 * POST /api/dishduty/trigger-daily-assignment
 * (No body needed, could be protected by a secret header or IP if necessary, or just admin pass for now)
 * For simplicity, not adding admin pass check here, assuming it's called by a trusted cron or admin action.
 */
routerAdd("POST", "/api/dishduty/trigger-daily-assignment", async (c) => {
    try {
        const result = await processDailyAssignments();
        return c.json(200, result);
    } catch (e) {
        console.error("Error in daily assignment trigger:", e);
        await logAction("daily_assignment_error", { error: e.toString() });
        return c.json(500, { error: "Internal Server Error during daily assignment." });
    }
});


/**
 * API Endpoint: Mark a task as "not done".
 * POST /api/dishduty/mark-not-done
 * Body: { date: string (YYYY-MM-DD for yesterday), admin_password: string }
 */
routerAdd("POST", "/api/dishduty/mark-not-done", async (c) => {
    const data = $apis.requestInfo(c).data;
    if (!isAdmin(data.admin_password)) {
        return c.json(403, { error: "Forbidden: Invalid admin password." });
    }

    if (!data.date) {
        return c.json(400, { error: "Bad Request: 'date' (for yesterday's task) is required." });
    }

    const yesterdayYMD = data.date; // Expecting YYYY-MM-DD
    const yesterdayFull = yesterdayYMD + " 00:00:00.000Z";
    const todayYMD = getTodayYMD();
    const todayFull = todayYMD + " 00:00:00.000Z";

    try {
        const assignmentToMark = await $app.dao().findFirstRecordByFilter(
            "assignments",
            "date = {:date}",
            { date: yesterdayFull }
        );

        if (!assignmentToMark) {
            return c.json(404, { error: `Not Found: No assignment found for date ${yesterdayYMD}.` });
        }

        const originalStatus = assignmentToMark.get("status");
        const failedWorkerId = assignmentToMark.get("worker_id");
        assignmentToMark.set("status", "not_done");
        await $app.dao().saveRecord(assignmentToMark);

        const failedWorker = await $app.dao().findRecordById("workers", failedWorkerId);

        // Reassign for Today
        // 1. Cancel/remove any existing assignment for today IF it's not the failed worker
        const existingTodayAssignment = await $app.dao().findFirstRecordByFilter(
            "assignments",
            "date = {:today}",
            { today: todayFull }
        );

        if (existingTodayAssignment && existingTodayAssignment.get("worker_id") !== failedWorkerId) {
            console.log(`Cancelling existing assignment for ${existingTodayAssignment.get("worker_id")} on ${todayYMD} to reassign to ${failedWorker.get("name")}`);
            await $app.dao().deleteRecord(existingTodayAssignment);
             await logAction("assignment_cancelled_for_reassignment", {
                date: todayYMD,
                cancelled_worker_id: existingTodayAssignment.get("worker_id"),
                reassigned_to_worker_id: failedWorkerId
            });
        }


        // 2. Create new assignment for failed_worker_id for today, if not already assigned to them
        let todayReassigned = false;
        if (!existingTodayAssignment || existingTodayAssignment.get("worker_id") !== failedWorkerId) {
            const assignmentsCollection = $app.dao().findCollectionByNameOrId("assignments");
            const newTodayAssignment = new Record(assignmentsCollection, {
                worker_id: failedWorkerId,
                date: todayFull,
                status: "assigned", // Reassignment is 'assigned'
            });
            await $app.dao().saveRecord(newTodayAssignment);
            todayReassigned = true;
            // Update failed worker's last_assigned_date if this is a new assignment for them today
            failedWorker.set("last_assigned_date", todayFull);
            await $app.dao().saveRecord(failedWorker);
        }


        // Shift subsequent assignments and queue items by one day
        // This is a complex part. We need to shift:
        // 1. Future 'assignments' records (status 'assigned' or 'pending')
        // 2. 'assignment_queue' items

        // Shift future assignments
        const futureAssignments = await $app.dao().findRecordsByFilter(
            "assignments",
            "date > {:today}", // All assignments after today
            { today: todayFull }
        );

        for (const assign of futureAssignments) {
            const originalDate = assign.get("date").split("T")[0];
            const newDate = addDaysToYMD(originalDate, 1);
            assign.set("date", newDate + " 00:00:00.000Z");
            await $app.dao().saveRecord(assign);
        }

        // Shift queue items
        const queueItems = await $app.dao().findRecordsByFilter(
            "assignment_queue",
            "1=1 ORDER BY order ASC" // Process all queue items
        );
        for (const item of queueItems) {
            const originalStartDate = item.get("start_date").split("T")[0];
            // Only shift if its start date is after or on the day the penalty is applied
            if (new Date(originalStartDate) >= new Date(todayYMD)) {
                 const newStartDate = addDaysToYMD(originalStartDate, 1);
                 item.set("start_date", newStartDate + " 00:00:00.000Z");
                 await $app.dao().saveRecord(item);
            }
        }

        await logAction("marked_not_done", {
            date: yesterdayYMD,
            original_status: originalStatus,
            failed_worker_id: failedWorkerId,
            failed_worker_name: failedWorker.get("name"),
            reassigned_today: todayReassigned,
            today_reassigned_to: todayReassigned ? failedWorkerId : null,
        });

        return c.json(200, {
            message: `Assignment for ${yesterdayYMD} marked 'not_done'. Worker ${failedWorker.get("name")} has been reassigned for ${todayYMD} if they weren't already. Subsequent assignments shifted.`,
        });

    } catch (e) {
        console.error("Error marking 'not done':", e);
        return c.json(500, { error: "Internal Server Error: Could not mark task as not done." });
    }
});


/**
 * API Endpoint: Get current assignee.
 * GET /api/dishduty/current-assignee
 */
routerAdd("GET", "/api/dishduty/current-assignee", async (c) => {
    const todayYMD = getTodayYMD();
    const todayFull = todayYMD + " 00:00:00.000Z";

    try {
        const currentAssignment = await $app.dao().findFirstRecordByFilter(
            "assignments",
            "date = {:today} AND status = 'assigned'",
            { today: todayFull }
        );

        if (currentAssignment) {
            const worker = await $app.dao().findRecordById("workers", currentAssignment.get("worker_id"));
            return c.json(200, {
                date: todayYMD,
                worker_id: worker.id,
                worker_name: worker.get("name"),
                status: currentAssignment.get("status"),
            });
        } else {
            // If no direct assignment, check if daily processing needs to run or if queue implies today's assignee
            // For simplicity, this endpoint just returns current "assigned". Frontend might need to trigger daily processing.
            // Or, we can try to run daily assignment here if nothing is found.
            // Let's try to run daily assignment if no one is assigned.
            console.log(`No current assignee for ${todayYMD}, attempting to process daily assignments.`);
            const processingResult = await processDailyAssignments(); // This might assign someone

            if (processingResult.assigned_worker_id) {
                 const newlyAssignedWorker = await $app.dao().findRecordById("workers", processingResult.assigned_worker_id);
                 return c.json(200, {
                    date: todayYMD,
                    worker_id: newlyAssignedWorker.id,
                    worker_name: newlyAssignedWorker.get("name"),
                    status: "assigned", // Assumed from processing
                    message: processingResult.message,
                });
            }

            return c.json(404, { message: "No worker is currently assigned for today.", details: processingResult });
        }
    } catch (e) {
        console.error("Error fetching current assignee:", e);
        return c.json(500, { error: "Internal Server Error." });
    }
});

/**
 * API Endpoint: Get calendar data (assignments and queue projections).
 * GET /api/dishduty/calendar?start_date=YYYY-MM-DD&end_date=YYYY-MM-DD
 */
routerAdd("GET", "/api/dishduty/calendar", async (c) => {
    const queryParams = $apis.requestInfo(c).query;
    const startDateParam = queryParams.start_date;
    const endDateParam = queryParams.end_date;

    if (!startDateParam || !endDateParam) {
        return c.json(400, { error: "Bad Request: start_date and end_date query parameters are required." });
    }

    // Validate date format (basic check)
    const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
    if (!dateRegex.test(startDateParam) || !dateRegex.test(endDateParam)) {
        return c.json(400, { error: "Bad Request: Dates must be in YYYY-MM-DD format." });
    }

    const startDateFull = startDateParam + " 00:00:00.000Z";
    const endDateFull = endDateParam + " 23:59:59.999Z"; // Ensure end of day

    try {
        const calendarEvents = [];

        // 1. Fetch actual assignments
        const assignments = await $app.dao().findRecordsByFilter(
            "assignments",
            "date >= {:start} AND date <= {:end}",
            { start: startDateFull, end: endDateFull },
            { sort: "date" } // Sort by date
        );

        const workerCache = {}; // Cache worker details to reduce DB queries

        for (const assignment of assignments) {
            let workerName = "Unknown Worker";
            if (workerCache[assignment.get("worker_id")]) {
                workerName = workerCache[assignment.get("worker_id")].name;
            } else {
                try {
                    const worker = await $app.dao().findRecordById("workers", assignment.get("worker_id"));
                    workerName = worker.get("name");
                    workerCache[assignment.get("worker_id")] = { name: workerName, id: worker.id };
                } catch (e) {
                    console.warn(`Could not find worker ${assignment.get("worker_id")} for assignment ${assignment.id}`);
                }
            }
            calendarEvents.push({
                id: "assign-" + assignment.id,
                title: workerName, // For FullCalendar: event title
                start: assignment.get("date").split("T")[0], // For FullCalendar: event start date
                allDay: true,
                extendedProps: {
                    type: "assignment",
                    worker_id: assignment.get("worker_id"),
                    worker_name: workerName,
                    status: assignment.get("status"),
                    assignment_id: assignment.id
                },
                // Basic styling based on status
                backgroundColor: assignment.get("status") === "not_done" ? "#FF7F7F" : (assignment.get("status") === "done" ? "#90EE90" : "#ADD8E6"),
                borderColor: assignment.get("status") === "not_done" ? "#FF0000" : (assignment.get("status") === "done" ? "#008000" : "#0073B0"),
            });
        }

        // 2. Fetch and project queue items
        // We need to project queue items that *would* fall into the requested date range
        const queueItems = await $app.dao().findRecordsByFilter(
            "assignment_queue",
            "1=1 ORDER BY order ASC" // Get all queue items to project correctly
        );

        let lastProjectedDate = null; // Keep track of the end date of the last projected item

        // Find the latest date from actual assignments within or before the range to anchor queue projections
        const latestAssignmentInRangeOrBefore = await $app.dao().findFirstRecordByFilter(
            "assignments",
            "date <= {:endDateParam}",
            { endDateParam: endDateFull },
            { sort: "-date" } // Get the most recent one
        );

        if (latestAssignmentInRangeOrBefore) {
            lastProjectedDate = latestAssignmentInRangeOrBefore.get("date").split("T")[0];
        }


        for (const item of queueItems) {
            let currentItemStartDateYMD = item.get("start_date").split("T")[0];
            const duration = item.get("duration_days");
            const workerId = item.get("worker_id");

            let workerName = "Queued Worker";
             if (workerCache[workerId]) {
                workerName = workerCache[workerId].name;
            } else {
                try {
                    const worker = await $app.dao().findRecordById("workers", workerId);
                    workerName = worker.get("name");
                    workerCache[workerId] = { name: workerName, id: worker.id };
                } catch (e) {
                    console.warn(`Could not find worker ${workerId} for queue item ${item.id}`);
                }
            }

            // Adjust start date if it's supposed to follow the lastProjectedDate
            if (lastProjectedDate && new Date(currentItemStartDateYMD) <= new Date(lastProjectedDate)) {
                currentItemStartDateYMD = addDaysToYMD(lastProjectedDate, 1);
            } else if (!lastProjectedDate && new Date(currentItemStartDateYMD) < new Date(getTodayYMD())) {
                // If no anchor and queue item is in past, project from today
                // This case should ideally be handled by daily assignment moving queue items.
                // But for pure projection, if start_date is past, and no assignments, project from today or its original start_date if it's future
                 currentItemStartDateYMD = (new Date(item.get("start_date").split("T")[0]) > new Date(getTodayYMD())) ? item.get("start_date").split("T")[0] : getTodayYMD();
            }


            for (let i = 0; i < duration; i++) {
                const projectedDate = addDaysToYMD(currentItemStartDateYMD, i);

                // Only add if it falls within the requested calendar range
                if (new Date(projectedDate) >= new Date(startDateParam) && new Date(projectedDate) <= new Date(endDateParam)) {
                    // Avoid adding duplicate projections for the same date if an actual assignment already exists
                    const existingEventOnDate = calendarEvents.find(event => event.start === projectedDate && event.extendedProps.type === "assignment");
                    if (!existingEventOnDate) {
                        calendarEvents.push({
                            id: "queue-" + item.id + "-day-" + i,
                            title: `${workerName} (Queued)`,
                            start: projectedDate,
                            allDay: true,
                            extendedProps: {
                                type: "queued_assignment",
                                worker_id: workerId,
                                worker_name: workerName,
                                queue_id: item.id,
                                order: item.get("order"),
                                duration_days: duration
                            },
                            backgroundColor: "#D3D3D3", // Light grey for queued
                            borderColor: "#A9A9A9",
                        });
                    }
                }
            }
            // Update lastProjectedDate for the next queue item
            lastProjectedDate = addDaysToYMD(currentItemStartDateYMD, duration - 1);
        }


        // Sort all events by date primarily, then by type (assignment before queued)
        calendarEvents.sort((a, b) => {
            const dateA = new Date(a.start);
            const dateB = new Date(b.start);
            if (dateA < dateB) return -1;
            if (dateA > dateB) return 1;
            // If dates are same, 'assignment' comes before 'queued_assignment'
            if (a.extendedProps.type === "assignment" && b.extendedProps.type === "queued_assignment") return -1;
            if (a.extendedProps.type === "queued_assignment" && b.extendedProps.type === "assignment") return 1;
            return 0;
        });


        return c.json(200, calendarEvents);

    } catch (e) {
        console.error("Error fetching calendar data:", e, e.stack);
        return c.json(500, { error: "Internal Server Error fetching calendar data." });
    }
});

/**
 * Example of a cron job that could run daily.
 * PocketBase's cron is configured in the Admin UI or via `pb_data/data.db`'s _cronjobs table.
 * This function shows what such a job might call.
 */
// cronAdd("nightly_assignment_job", "0 1 0 * * *", async () => { // Example: Run daily at 00:01 AM server time
//     console.log("Executing nightly assignment job...");
//     try {
//         await processDailyAssignments();
//         console.log("Nightly assignment job completed.");
//     } catch (error) {
//         console.error("Error in nightly assignment job:", error);
//         await logAction("cron_job_error", { job_name: "nightly_assignment_job", error: error.toString() });
//     }
// });
// Note: Actual cron job setup is outside this script. The `cronAdd` is illustrative.
// You would typically set up a cron job in PocketBase Admin UI to call the
// `/api/dishduty/trigger-daily-assignment` endpoint or directly invoke `processDailyAssignments` if possible
// depending on how PocketBase executes its cron tasks (e.g. if it can call internal functions).
// For now, the endpoint `/api/dishduty/trigger-daily-assignment` is the primary way to run it.

console.log("DishDuty backend hooks loaded.");